{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to zkWasm Development Recipe","text":"<p>The zkWasm Development Recipe focuses on building trustless blockchain applications using zkWasm and related technologies. It will start from scratch, from understanding blockchain and zero-knowledge proofs, to learning the basics and architecture of zkWasm, and then to developing a complete application, allowing you to transform from a beginner to an advanced zkWasm developer.</p> <p>Of course, this Development Recipe can serve as both an introductory tutorial for beginners and a reference manual for developing zkWasm applications. Each chapter corresponds to a step in developing a full-stack zkWasm application.</p> <p>Note</p> <p>This is still a work in progress. We will keep updating it with the latest information and best practices.</p>"},{"location":"index.html#learning-experience","title":"Learning Experience","text":"<p>Here's what you can expect from this recipe:</p> <ul> <li>Workflow: A smooth development learning experience following a \"learn - design - develop - test - deploy\" workflow</li> <li>Tools: Useful tools and guidance for developing games, web, and backend applications </li> <li>Guidance: Step-by-step code examples and practical guidance</li> </ul> <p>Content Format:</p> <ul> <li>Text: Clear and concise explanations to help you understand the concepts and principles</li> <li>Code: Step-by-step code examples to guide you through the development process</li> <li>Video: Visual explanations to help you understand the concepts and principles</li> <li>Quiz: Test your understanding of the concepts and principles</li> <li>Supplemental Resources: Additional resources to further enhance your learning</li> <li>FAQ: Answers to frequently asked questions</li> </ul> <p>You will build skills and confidence in the following areas:</p> <ul> <li>Blockchain and zkWasm engineering</li> <li>Application design</li> <li>Frontend development with React, TypeScript, and Web3 libraries</li> <li>Backend development with Rust and zkWasm </li> <li>Environment setup, testing, debugging, and deployment</li> </ul> <p>This will equip you to build your own zkWasm applications from the ground up.</p> <p>Upon completing this Development Recipe, you'll have several exciting paths to explore:</p> <ul> <li>Hackathons: Put your skills to the test by participating in hackathons across various ecosystems and showcasing your zkWasm prowess</li> <li>Entrepreneurship: Embark on an entrepreneurial journey by building your own innovative products and starting a company, with the support of Delphinus Labs</li> <li>Ecosystem Contribution: Contribute to the growth of the zkWasm ecosystem by creating essential tools and libraries, with grants from Delphinus Labs</li> <li>Career Development: Launch your career as a sought-after full-stack developer in the thriving blockchain industry</li> <li>Academic Research: Delve deeper into the academic realm by pursuing research on zkWasm and pushing the boundaries of this cutting-edge technology</li> <li>Discover Opportunities: Discover countless other opportunities to apply your newfound expertise and make your mark in the world of blockchain and zero-knowledge proofs</li> </ul>"},{"location":"index.html#ready-to-get-started","title":"Ready to get started?","text":"<p>Here are a few steps you should follow to ensure a great development experience:</p>"},{"location":"index.html#join-the-discord-community","title":"Join the Discord Community","text":"<p>Delphinus Labs Discord Community </p> <ul> <li>Ask questions, share your ideas, and get help from the community. </li> <li>\"The best way to learn is by teaching.\u201d If you see others who are stuck, help them out! </li> <li>There are also many events and activities organized by the community which you can participate in.</li> </ul>"},{"location":"index.html#join-the-telegram-dev-chat","title":"Join the Telegram Dev Chat","text":"<p>Please DM The Developer Relations Team </p> <ul> <li>Direct Message the developer relations team to be invited into the telegram chat group.</li> <li>You can get help from the developer relations team, also you will be able to connect with other developers. </li> <li>Please also give us your feedback and suggestions on how to improve the development experience.</li> </ul> <p>Let's dive in!</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"\ud83d\ude80 Quick Tutorial <p>Get started quickly with a hands-on tutorial</p> Start Building \u2192 \ud83d\udd30 Core Concepts <p>Learn the fundamental concepts of blockchain application development</p> Start Learning \u2192 \u2699\ufe0f Setup Guide <p>Set up your development environment</p> Get Ready \u2192 \ud83d\ude80 zkWasm Overview <p>Learn the basics of zkWasm</p> Start Learning \u2192"},{"location":"Core%20Concepts.html","title":"Core Concepts","text":""},{"location":"Core%20Concepts.html#1-understanding-web-application-development","title":"1. Understanding Web Application Development","text":"<p>In modern web application development, the frontend and backend have clear divisions of labor. Although technologies are constantly evolving, one thing remains constant: the frontend is responsible for presenting the state, while the backend is responsible for managing the state.</p> <p>Note</p> <ul> <li>The recipe focuses on web application development due to zkWasm's strong ties with WebAssembly. However, zkWasm is not limited to web applications, you can use zkWasm to develop applications such as games for other platforms.</li> <li>Wasm's widespread support in web browsers makes it easier to integrate zkWasm into web applications.</li> <li>The zkWasm ecosystem and Delphinus Labs provide web-friendly tools and libraries for a streamlined development process.</li> </ul>"},{"location":"Core%20Concepts.html#backend-state-storage-and-transformation","title":"Backend: State Storage and Transformation","text":"<p>The backend is the core of an application, and its main responsibilities include:</p> <ol> <li> <p>State Storage: The backend stores the application's state data, which can be kept in memory or persisted in a database. Common storage methods include relational databases (like MySQL) and non-relational databases (like MongoDB).</p> </li> <li> <p>State Transformation: The backend receives requests from the frontend, transforms the state according to business logic, and returns the new state to the frontend. This process can be seen as a state machine, where each request triggers a state transition.</p> </li> <li> <p>Business Logic: The backend handles complex business logic, such as user authentication, access control, and data validation, ensuring the legitimacy and security of state transitions.</p> </li> </ol>"},{"location":"Core%20Concepts.html#frontend-state-presentation-and-interaction","title":"Frontend: State Presentation and Interaction","text":"<p>The frontend directly faces the user, and its main responsibilities include:</p> <ol> <li> <p>State Presentation: The frontend renders the state data returned by the backend into a user interface. Traditional web pages use HTML to describe content structure and CSS to describe appearance. Modern web applications often use JavaScript frameworks (like React or Vue) to declaratively describe the mapping between UI and state.</p> </li> <li> <p>User Interaction: The frontend handles various user interactions, such as mouse clicks, keyboard input, and touch events. When the user performs an action, the frontend updates the UI state and passes the user's intent to the backend.</p> </li> <li> <p>Local State Management: Although the backend is the main manager of state, the frontend also needs to manage some local UI states, such as the currently selected tab or whether a modal is shown. These states are usually related to specific UI components and do not need to be passed to the backend.</p> </li> </ol>"},{"location":"Core%20Concepts.html#frontend-backend-separation-state-synchronization","title":"Frontend-Backend Separation: State Synchronization","text":"<p>As the division between frontend and backend becomes clearer, frontend-backend separation has become the mainstream model of web development. In this model, the frontend and backend communicate through APIs and need to agree on data formats and communication protocols. We can view the interaction between frontend and backend as a process of synchronizing state from the backend to the frontend: the frontend requests the backend API, the backend returns or updates state data, and the frontend updates the UI based on the state data.</p> <p></p> <p>In summary, in a frontend-backend separated architecture, state management requires close cooperation between the frontend and backend. Both sides need to reach agreement on API design, data synchronization, authentication, and other aspects to jointly maintain the application's state.</p>"},{"location":"Core%20Concepts.html#2-understanding-state-management","title":"2. Understanding State Management","text":"<p>We've discussed the roles of the frontend and backend in state management. It's clear that regardless of frontend or backend, state management is a core issue in application development. So, what is state? Why is state management so important?</p> <p>In software development, state is everywhere:</p> <ul> <li>On the backend, state could be data in a database, objects in memory, files in a filesystem, etc.</li> <li>On the frontend, state could be the structure of the DOM tree, CSS styles, JavaScript variables, etc.</li> </ul> <p>Broadly speaking, state is a snapshot of a program at a certain moment. It determines the program's current behavior and future direction. Managing state well means managing the program well.</p>"},{"location":"Core%20Concepts.html#state-is-a-snapshot-of-the-system-or-application","title":"State is a \"Snapshot\" of the System or Application","text":"<p>In computer science, we often say \"program = data structure + algorithm\". Data structure, in essence, is a representation of the system's state. The system's state at any moment determines its current behavior and properties. Understanding and managing state is the foundation of controlling the system.</p> <p>Here are a few examples:</p> <ul> <li>The process management in an operating system is essentially managing the state transitions of processes (ready, running, blocked, etc.).</li> <li>Variables in a programming language can be seen as a representation of the program's state. Functional languages emphasize immutable state to reduce the complexity of state management.</li> <li>The ACID properties of databases are meant to ensure the consistency of state before and after transactions.</li> </ul> <p>Or more vividly:</p> <ul> <li>In games, a character's movement, attack, skill release, etc., are all processes of state transition.</li> <li>In social networks, a user's state (like follow, like, comment) determines the display of the information flow.</li> <li>In e-commerce websites, the state of a user's shopping cart, order status, etc., determines the recommendation system and search results.</li> </ul> <p>The primary task of state management is to choose the right data structure to represent the system's state space. A good state representation should be concise, complete, and easy to verify.</p>"},{"location":"Core%20Concepts.html#state-transition-reflects-the-systems-behavior","title":"State Transition Reflects the System's Behavior","text":"<p>If state is a \"snapshot\" of the system, then state transition is the \"script\" of the system's behavior. The dynamic behavior of the system can be seen as the result of a series of state transitions. Each input or event may cause a change in state, thereby changing the system's behavior.</p> <p>The management of state transitions involves several key issues:</p> <ol> <li>Transition Function: Given the current state and input, how to calculate the next state.</li> <li>Consistency: How to ensure the consistency of the final result of concurrent state transitions.</li> <li>Fault Tolerance: How to handle invalid state transitions and prevent the system from entering an erroneous state.</li> </ol> <p>For example:</p> <ul> <li>In a game, a player's attack may cause changes in multiple states, including the attacker's state, the defender's state, the game scene's state, etc.</li> <li>In a social network, a user's like may cause changes in multiple states, including the liker's state, the liked person's state, the recommendation system's state, etc.</li> <li>On an e-commerce website, a user's cart checkout may cause changes in multiple states, including the shopping cart's state, the order's state, the recommendation system's state, etc.</li> </ul> <p>Many engineering problems, such as concurrency control and exception handling, can essentially be boiled down to the management of state transitions. Good state management should ensure:</p> <ol> <li>State Space: All possible states are safe and controllable.</li> <li>State Transition: Any transition satisfies the predefined constraints.</li> <li>State Consistency: All replicas or views eventually converge to a consistent state.</li> </ol> <p>Understanding state management allows us to better understand the essence of blockchain development.</p>"},{"location":"Core%20Concepts.html#3-understanding-blockchain-engineering","title":"3. Understanding Blockchain Engineering","text":"<p>In blockchain application development, the blockchain can replace or partially replace the traditional backend as a distributed database and server. </p> <p></p> <p>The core of blockchain engineering is managing global state in a decentralized network. Here, state can be account balances, smart contract variables, token ownership, etc. Unlike traditional centralized systems, state management in blockchain faces several major challenges.</p>"},{"location":"Core%20Concepts.html#decentralized-storage-of-global-state","title":"Decentralized Storage of Global State","text":"<p>The global state of the blockchain is maintained by all nodes together. Each node saves a complete copy of the state. Although this decentralized storage improves the system's availability and fault tolerance, it also brings several problems:</p> <ol> <li>State Synchronization: How do newly joined nodes obtain the latest state from other nodes?</li> <li>State Validation: How to quickly verify the legitimacy of a state to prevent malicious nodes from injecting erroneous states?</li> <li>State Storage: How to design efficient data structures for synchronizing and verifying state among nodes?</li> </ol> <p>For example, Ethereum uses Merkle Patricia Trees to store state, which can quickly verify state consistency and support state queries by light nodes.</p>"},{"location":"Core%20Concepts.html#consensus-mechanism-for-state-transitions","title":"Consensus Mechanism for State Transitions","text":"<p>State transitions in the blockchain are triggered by transactions. But in a decentralized network, reaching consensus on the order and legitimacy of transactions is a very tricky problem. Consensus mechanisms, such as PoW and PoS, provide a way to reach agreement on state transitions among untrusted nodes.</p> <p>The consensus mechanism needs to solve several problems:</p> <ol> <li>Consistency: How to ensure that honest nodes see a consistent order of state transitions?</li> <li>Liveness: How to ensure that state transitions can be completed within a finite time, without livelock or deadlock?</li> <li>Incentive: How to incentivize nodes to participate in consensus and punish malicious behavior?</li> </ol> <p>For example, Bitcoin's PoW reaches consensus through computing power competition, while Ethereum's PoS chooses block-producing nodes through staking and randomness.</p>"},{"location":"Core%20Concepts.html#state-management-in-smart-contracts","title":"State Management in Smart Contracts","text":"<p>Smart contracts are one of the most powerful features of blockchain. They allow developers to deploy arbitrary state transition logic on the blockchain. From a programming perspective, each contract is like a state machine, managing a set of state variables and performing state transitions based on transaction inputs.</p> <p>State management in smart contracts involves several key issues:</p> <ol> <li>State Representation: How to abstract complex business logic and data structures with state variables?</li> <li>State Transition: How to ensure that each state transition is deterministic and verifiable?</li> <li>Concurrency Control: How to handle concurrent state access and modification to prevent race conditions?</li> </ol> <p>Ethereum's EVM provides a runtime environment for smart contracts. The Solidity programming language supports various state variable types, such as uint, mapping, struct, etc. Contract functions implement state transitions by reading and writing state variables.</p>"},{"location":"Core%20Concepts.html#state-extension-in-layer2-or-rollup-applications","title":"State Extension in Layer2 or Rollup Applications","text":"<p>State storage and transitions in blockchain are all done on Layer1 (mainchain). But due to the limitations of consensus mechanisms and storage capacity, the state throughput of Layer1 is very limited. To extend state capacity, Layer2 solutions emerged.</p> <p>Layer2 solutions, such as state channels and rollups, process state off-chain and only interact with Layer1 at critical moments (such as final state submission), thus greatly improving state throughput. But this also puts higher requirements on state management:</p> <ol> <li>State Sharding: How to split state into multiple Layer2s for parallel processing?</li> <li>Fraud Proofs: How to use cryptographic methods to prove the legitimacy of off-chain state transitions?</li> <li>State Submission: How to securely and efficiently submit Layer2 state to Layer1?</li> </ol> <p>For example, zkRollup uses zero-knowledge proofs to verify off-chain state transitions, while Optimistic Rollup ensures state legitimacy through fraud proofs and challenge periods. zkWasm achieves deterministic and verifiable state transitions by compiling state transition logic into Wasm bytecode and executing it in a zkVM.</p>"},{"location":"Core%20Concepts.html#4-understanding-zero-knowledge-proofs","title":"4. Understanding Zero-Knowledge Proofs","text":"<p>The most significant role of blockchain as a distributed system is verification. We mentioned earlier that zkWasm achieves deterministic and verifiable state transitions, so why do we need verification? What is determinism and verifiability in the context of blockchain, and what role does zero-knowledge proof play in it?</p> <p>Let's start with the essential properties of blockchain. Blockchain is a decentralized network where each node is equal, and there is no centralized authority. This brings the following problems:</p> <ul> <li>How to reach consensus among untrusted nodes? </li> <li>How to ensure that the state transitions seen by each node are consistent and correct?</li> </ul> <p>This requires the introduction of a verification mechanism. When accepting a new state transition (such as a transaction or a new block), each node needs to verify its legitimacy. Only state transitions that pass verification can be added to the blockchain and become part of the global consensus.</p> <p>To achieve reliable verification, determinism and verifiability are needed:</p> <ul> <li> <p>Determinism means that given the same input, the same output is always obtained. In blockchain, determinism means that each node, executing the same state transition logic, will get the same result. This is the premise of reaching consensus. Imagine if the result of a state transition is non-deterministic (for example, dependent on the execution environment or random numbers), different nodes might get different states, breaking the consensus.</p> </li> <li> <p>Verifiability means that the correctness of a state transition can be efficiently verified. In blockchain, verifiability means that any node can quickly check whether a state transition is legal without redoing all the computations. Imagine if verifying a state transition requires replaying the entire computation process, the cost of verification would be as high as generating the state transition, which is unacceptable in computationally intensive situations.</p> </li> </ul> <p>Traditional blockchains (like Bitcoin and Ethereum) achieve determinism by replaying every transaction on each node, and achieve verifiability through a hash-linked block structure. But this method is less efficient, especially when the state transition logic is complex.</p> <p>This is where zero-knowledge proofs come into play. Zero-knowledge proofs are a cryptographic technique that can prove a statement is correct without revealing any information. In blockchain, zero-knowledge proofs can be used to prove that a state transition is legal without revealing the specific input data and intermediate states. More Information about Zero-Knowledge Proofs can be found here or Later in Supplemental Resources.</p> <p>Zero-knowledge proofs provide a more efficient way to implement determinism and verifiability:</p> <ul> <li> <p>For determinism, zero-knowledge proofs require the state transition logic to be deterministic (like zkWasm using a deterministic Wasm subset) to generate proofs.</p> </li> <li> <p>For verifiability, zero-knowledge proofs allow the prover to generate a succinct proof proving the correctness of the state transition, and the verifier only needs to check this proof without redoing the computation. This greatly reduces the cost of verification.</p> </li> </ul> <p>Here's an example. Suppose there is a complex state transition that requires 1,000,000 steps of computation. In a traditional blockchain, each node would need to replay these 1,000,000 steps to verify the result. But with zero-knowledge proofs, the prover only needs to do the computation once to generate a proof, and the verifier might only need to do 100 steps of computation to verify this proof.</p> <p>In addition to efficiency, zero-knowledge proofs bring another important property: privacy. Since the proving process does not reveal input data and intermediate states, zero-knowledge proofs allow verifying the correctness of a computation result without disclosing the original data. This is very important for privacy-sensitive application scenarios (like finance and healthcare).</p>"},{"location":"Core%20Concepts.html#supplemental-resources","title":"Supplemental Resources","text":"<ul> <li>Zero-Knowledge Mastery: A comprehensive guide to zero-knowledge proofs.</li> <li>zkhack: zkhack is a hub for zk learning and building. It hosts virtual events and advanced puzzle competitions, as well as produces educational content and runs study groups. Its goal is to explore and explain key concepts and tools and get you onboarded into zk.</li> <li>zksummit: The annual zkSummit conference, an important event in the zero-knowledge proof community. The conference brings together the best thinkers and builders to discuss the latest in zero knowledge research, zk use-cases, cryptographic primitives, privacy and maths. </li> <li>progcrypto: The Programmable Cryptography Conference is a 2-day event, organized by 0xPARC and PSE, which brings together researchers, developers, and community members focused on next-generation cryptography and its applications. Topics include new research developments in applied cryptography, infrastructure for tools like zkSNARKs and MPC, and applications of these new cryptographic primitives for areas such as digital identity or financial privacy.</li> </ul> <p>Next, we will introduce the core concepts and fundamentals of zkWasm.</p>"},{"location":"Quick%20Tutorial.html","title":"Quick Tutorial","text":""},{"location":"Quick%20Tutorial.html#guideline","title":"Guideline","text":"<p>This tutorial will guide you through the process of creating a simple zkWasm application in minutes. Please make sure you have already setup the environment by following the Setup Environment guide.</p>"},{"location":"Quick%20Tutorial.html#step-1-install-the-zkwasm-mini-rollup-service","title":"Step 1: Install the zkWasm Mini-Rollup service","text":"<p>The zkWasm Mini-Rollup service is a RESTful service that provides the zkWasm runtime environment. It provides the following functionalities:</p> <ul> <li>Serve the zkWasm runtime environment</li> <li>Provide the zkWasm REST API</li> <li>Maintain the zkWasm state through merkle tree enabled database and Redis</li> <li>Generate the witness from the merkle tree database for zkWasm verification</li> <li>Calculate the new merkle tree root when receiving the zkWasm transaction batch for settlement</li> </ul>"},{"location":"Quick%20Tutorial.html#1-get-the-zkwasm-mini-rollup-service","title":"1. Get the zkWasm Mini-Rollup service","text":"<p>You can get the zkWasm Mini-Rollup service by cloning the repository: <pre><code>git clone https://github.com/DelphinusLab/zkwasm-mini-rollup.git\ncd zkwasm-mini-rollup\n</code></pre> Or, download the zip file from the Github page and unzip it.</p>"},{"location":"Quick%20Tutorial.html#2-start-the-zkwasm-mini-rollup-service","title":"2. Start the zkWasm Mini-Rollup service","text":"<p>In the root directory of the zkWasm Mini-Rollup service, run: <pre><code>docker-compose up\n</code></pre> Make sure your running environment has the permission to access the Docker daemon. This command will start a Docker container named <code>zkwasm-mini-rollup</code>.</p> <p>Note</p> <p>One zkWasm Mini-Rollup service must correspond to one zkWasm rollup application. This will be improved in the future by supporting multiple rollup applications in one service.</p>"},{"location":"Quick%20Tutorial.html#step-2-get-the-template-project","title":"Step 2: Get the Template Project","text":"<p>Clone the template project - The Hello World Rollup: <pre><code>git clone https://github.com/DelphinusLab/helloworld-rollup\ncd helloworld-rollup\n</code></pre></p> <p>Project Structure</p> <p>The template includes: <pre><code>helloworld-rollup/\n\u251c\u2500\u2500 src/           # Rust source code - for application logic\n\u251c\u2500\u2500 ts/            # TypeScript code - for API testing\n\u251c\u2500\u2500 Cargo.toml     # Rust dependencies\n\u251c\u2500\u2500 Makefile       # Build scripts\n\u2514\u2500\u2500 rust-toolchain # Rust version specification\n</code></pre></p> <p>Install the dependencies for ts: <pre><code>cd ts\nnpm install\n</code></pre></p> <p>After installing the dependencies, compile the ts code: <pre><code>npx tsc\n</code></pre> This will generate the js code in the <code>ts/</code> directory and facilitate the backend server running and testing.</p> <p>Build the project using make: <pre><code>cd ..   #Move to the root directory of the project\nmake build\n</code></pre></p>"},{"location":"Quick%20Tutorial.html#step-3-run-the-rollup-application","title":"Step 3: Run the Rollup Application","text":"<p>In the root directory of the project, run: <pre><code>make run\n</code></pre></p> <p>This will start the backend server by running the <code>node ./ts/src/service.js</code>.</p> <p>You shall see some output like the following: <pre><code>rpc bind merkle server: http://127.0.0.1:3030\ninitialize mongoose ...\nstart express server\nServer is running on http://0.0.0.0:3000\nconnecting redis server: localhost\nbootstrapping ... (deploymode: false, remote: false, migrate: false)\nloading wasm application ...\ncheck merkel database connection ...\ninitialize sequener queue ...\nwaiting Count is: 0  perform draining ...\ninitialize application merkle db ...\n</code></pre></p> <p>Congratulations! You have successfully started the zkWasm rollup application. However, in order to build your own rollup application, you need to understand the core components of the zkWasm rollup application.</p>"},{"location":"Quick%20Tutorial.html#step-4-the-code-overview","title":"Step 4: The Code Overview","text":"<p>Let's examine the core components of our zkWasm application. This hello world rollup application is structured into several key Rust files, each handling specific functionality. </p>"},{"location":"Quick%20Tutorial.html#server-side-code-backend-code","title":"Server Side Code (Backend Code)","text":""},{"location":"Quick%20Tutorial.html#main-entry-point-srclibrs","title":"Main Entry Point (<code>src/lib.rs</code>)","text":"<pre><code>use wasm_bindgen::prelude::*;\nuse zkwasm_rest_abi::*;\npub mod config;\npub mod state;\npub mod settlement;\n\nuse crate::config::Config;\nuse crate::state::{State, Transaction};\nzkwasm_rest_abi::create_zkwasm_apis!(Transaction, State, Config);\n</code></pre> <p>The above code includes the following key components:</p> <ul> <li><code>wasm_bindgen</code>: Enables Rust-JavaScript interoperability</li> <li><code>zkwasm_rest_abi</code>: Provides core zkWasm functionality</li> <li><code>create_zkwasm_apis!</code>: Macro that generates necessary API endpoints</li> </ul>"},{"location":"Quick%20Tutorial.html#configuration-srcconfigrs","title":"Configuration (<code>src/config.rs</code>)","text":"<pre><code>use serde::Serialize;\n\n#[derive(Serialize, Clone)]\npub struct Config {\n    version: &amp;'static str,\n}\n\nlazy_static::lazy_static! {\n    pub static ref CONFIG: Config = Config {\n        version: \"1.0\"\n    };\n}\n\nimpl Config {\n    pub fn to_json_string() -&gt; String {\n        serde_json::to_string(&amp;CONFIG.clone()).unwrap()\n    }\n\n    pub fn autotick() -&gt; bool {\n        true\n    }\n}\n</code></pre> <p>The <code>Config</code> struct:</p> <ul> <li>Defines application configuration</li> <li>Provides JSON serialization for config values</li> <li>Controls auto-tick behavior - the system will automatically advance its state through tick events, facilitating time-based state transitions in the zkWasm runtime. </li> </ul> <p>Note</p> <p>Currently, the time interval is set to 5 seconds in the server side, which you can modify in the <code>service.ts</code> file in the <code>/src</code> directory of the <code>zkwasm-ts-server</code> package.</p>"},{"location":"Quick%20Tutorial.html#settlement-management-srcsettlementrs","title":"Settlement Management (<code>src/settlement.rs</code>)","text":"<pre><code>use zkwasm_rest_abi::WithdrawInfo;\n\npub struct SettlementInfo(Vec&lt;WithdrawInfo&gt;);\npub static mut SETTLEMENT: SettlementInfo = SettlementInfo(vec![]);\n\nimpl SettlementInfo {\n    pub fn append_settlement(info: WithdrawInfo) {\n        unsafe { SETTLEMENT.0.push(info) };\n    }\n\n    pub fn flush_settlement() -&gt; Vec&lt;u8&gt; {\n        zkwasm_rust_sdk::dbg!(\"flush settlement\\n\");\n        let sinfo = unsafe { &amp;mut SETTLEMENT };\n        let mut bytes: Vec&lt;u8&gt; = Vec::with_capacity(sinfo.0.len() * 32);\n        for s in &amp;sinfo.0 {\n            bytes.extend_from_slice(&amp;s.feature.to_le_bytes());\n            bytes.extend_from_slice(&amp;s.address);\n            bytes.extend_from_slice(&amp;s.amount.to_le_bytes());\n        }\n        sinfo.0 = vec![];\n        bytes\n    }\n}\n</code></pre> <p>The <code>SettlementInfo</code> struct:</p> <ul> <li>Handles withdrawal information</li> <li>Converts settlement data to bytes for processing</li> <li>Implements flush mechanism for batch processing</li> </ul> <p>Note</p> <p>In the current architecture of zkWasm Rollup Application, the withdrawal requests from users are handled in the server side. When settlement is triggered, the server will collect all the withdrawals and send them with merkle tree root to the zkWasm protocol contract for verification. </p>"},{"location":"Quick%20Tutorial.html#state-management-srcstaters","title":"State Management (<code>src/state.rs</code>)","text":""},{"location":"Quick%20Tutorial.html#1-player-data-structure","title":"1. Player Data Structure","text":"<pre><code>#[derive(Debug, Serialize)]\npub struct PlayerData {\n    pub counter: u64,\n}\n\nimpl Default for PlayerData {\n    fn default() -&gt; Self {\n        Self { counter: 0 }\n    }\n}\n\nimpl StorageData for PlayerData {\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Self {\n        let counter = *u64data.next().unwrap();\n        PlayerData { counter }\n    }\n    fn to_data(&amp;self, data: &amp;mut Vec&lt;u64&gt;) {\n        data.push(self.counter);\n    }\n}\n\npub type HelloWorldPlayer = Player&lt;PlayerData&gt;;\n</code></pre> <p>The <code>PlayerData</code> struct:</p> <ul> <li>Defines player-specific data structure with a <code>counter</code> field</li> <li>Implements <code>Default</code> trait for initializing new players with counter set to 0</li> <li>Implements <code>StorageData</code> trait for data serialization and deserialization</li> <li>Creates a type alias <code>HelloWorldPlayer</code> for Player with PlayerData</li> </ul>"},{"location":"Quick%20Tutorial.html#2-state-structure","title":"2. State Structure","text":"<pre><code>#[derive(Serialize)]\npub struct State {\n    counter: u64\n}\n\nimpl State {\n    pub fn get_state(pkey: Vec&lt;u64&gt;) -&gt; String {\n        let player = HelloWorldPlayer::get_from_pid(&amp;HelloWorldPlayer::pkey_to_pid(&amp;pkey.try_into().unwrap()));\n        serde_json::to_string(&amp;player).unwrap()\n    }\n\n    pub fn rand_seed() -&gt; u64 {\n        0\n    }\n\n    pub fn store(&amp;self) {\n    }\n\n    pub fn initialize() {\n    }\n\n    pub fn new() -&gt; Self {\n        State {\n            counter: 0,\n        }\n    }\n\n    pub fn snapshot() -&gt; String {\n        let state = unsafe { &amp;STATE };\n        serde_json::to_string(&amp;state).unwrap()\n    }\n\n    pub fn preempt() -&gt; bool {\n        let state = unsafe { &amp;STATE };\n        return state.counter &gt;= 20;\n    }\n\n    pub fn flush_settlement() -&gt; Vec&lt;u8&gt; {\n        let data = SettlementInfo::flush_settlement();\n        unsafe { STATE.store() };\n        data\n    }\n\n    pub fn tick(&amp;mut self) {\n        self.counter += 1;\n    }\n}\n</code></pre> <p>The <code>State</code> struct:</p> <ul> <li>Maintains global state with a counter field - The counter can be used to track the number of transactions processed</li> <li>Provides methods for state manipulation and querying, such as <code>get_state</code>, <code>store</code></li> <li>Implements serialization for state snapshots</li> <li>Handles settlement flushing and state updates, such as <code>flush_settlement</code></li> </ul> <p>We can also notice that there is a global variable <code>STATE</code> with field <code>counter</code> in the code. This is the state of the zkWasm rollup application, which shall be distinguished from the <code>counter</code> field in the <code>PlayerData</code> struct: <pre><code>pub static mut STATE: State = State {\n    counter: 0\n};\n</code></pre></p>"},{"location":"Quick%20Tutorial.html#3-transaction-handler","title":"3. Transaction Handler","text":"<pre><code>pub struct Transaction {\n    pub command: u64,\n    pub data: Vec&lt;u64&gt;,\n}\n\nconst AUTOTICK: u64 = 0;\nconst INSTALL_PLAYER: u64 = 1;\nconst INC_COUNTER: u64 = 2;\n\nconst ERROR_PLAYER_ALREADY_EXIST: u32 = 1;\nconst ERROR_PLAYER_NOT_EXIST: u32 = 2;\n\nimpl Transaction {\n    pub fn decode_error(e: u32) -&gt; &amp;'static str {\n        match e {\n            ERROR_PLAYER_NOT_EXIST =&gt; \"PlayerNotExist\",\n            ERROR_PLAYER_ALREADY_EXIST =&gt; \"PlayerAlreadyExist\",\n            _ =&gt; \"Unknown\"\n        }\n    }\n\n    pub fn decode(params: [u64; 4]) -&gt; Self {\n        let command = params[0] &amp; 0xff;\n        let data = vec![params[1], params[2], params[3]]; // pkey[0], pkey[1], amount\n        Transaction {\n            command,\n            data,\n        }\n    }\n\n    pub fn install_player(&amp;self, pkey: &amp;[u64; 4]) -&gt; u32 {\n        zkwasm_rust_sdk::dbg!(\"install \\n\");\n        let pid = HelloWorldPlayer::pkey_to_pid(pkey);\n        let player = HelloWorldPlayer::get_from_pid(&amp;pid);\n        match player {\n            Some(_) =&gt; ERROR_PLAYER_ALREADY_EXIST,\n            None =&gt; {\n                let player = HelloWorldPlayer::new_from_pid(pid);\n                player.store();\n                0\n            }\n        }\n    }\n\n    pub fn inc_counter(&amp;self, _pkey: &amp;[u64; 4]) -&gt; u32 {\n        todo!()\n    }\n\n    pub fn process(&amp;self, pkey: &amp;[u64; 4], _rand: &amp;[u64; 4]) -&gt; u32 {\n        match self.command {\n            AUTOTICK =&gt; {\n                unsafe { STATE.tick() };\n                return 0;\n            },\n            INSTALL_PLAYER =&gt; self.install_player(pkey),\n            INC_COUNTER =&gt; self.inc_counter(pkey),\n            _ =&gt; {\n                return 0\n            }\n        }\n    }\n}\n</code></pre> <p>The <code>Transaction</code> struct:</p> <ul> <li>Defines transaction structure and command types</li> <li>Handles player installation and counter increment operations (todo)</li> <li>Implements error handling with specific error codes</li> <li>Provides transaction decoding and processing functionality</li> <li>Uses pattern matching for command routing</li> </ul> <p>You may notice that the <code>process</code> method in the <code>Transaction</code> struct is the core method that handles the transaction processing:</p> <p><pre><code>pub fn process(&amp;self, pkey: &amp;[u64; 4], _rand: &amp;[u64; 4]) -&gt; u32 {\n    match self.command {\n        AUTOTICK =&gt; {\n            unsafe { STATE.tick() };\n            return 0;\n        },\n        INSTALL_PLAYER =&gt; self.install_player(pkey),\n        INC_COUNTER =&gt; self.inc_counter(pkey),\n        _ =&gt; {\n            return 0\n        }\n    }\n}\n</code></pre> It receives the transaction command and then routes the transaction to the corresponding handler based on the command. In this case, we have three commands:</p> <ul> <li><code>AUTOTICK</code>: Automatically tick the state of the rollup application, which increments the <code>counter</code> field in the <code>State</code> struct by 1</li> <li><code>INSTALL_PLAYER</code>: Install a new player, which creates a new player with a unique <code>pid</code> and initializes its <code>PlayerData</code></li> <li><code>INC_COUNTER</code>: Increment the counter of a player, which increments the <code>counter</code> field in the <code>PlayerData</code> struct by 1</li> </ul> <p>This process is the core logic of the zkWasm rollup application, which you can refer to implement your own application logic.</p>"},{"location":"Quick%20Tutorial.html#client-side-code-frontend-code","title":"Client Side Code (Frontend Code)","text":"<p>The client-side code is written in TypeScript and provides a convenient interface for interacting with the hello world zkWasm rollup application. Let's examine the key components:</p>"},{"location":"Quick%20Tutorial.html#constants-and-helper-functions","title":"Constants and Helper Functions","text":"<pre><code>const CMD_INSTALL_PLAYER = 1n;\nconst CMD_INC_COUNTER = 2n;\n\nfunction createCommand(nonce: bigint, command: bigint, feature: bigint) {\n    return (nonce &lt;&lt; 16n) + (feature &lt;&lt; 8n) + command;\n}\n</code></pre> <ul> <li>Two command constants are defined for player installation and counter incrementing</li> <li><code>createCommand</code> helper function constructs command values by combining:<ul> <li><code>nonce</code>: Transaction sequence number</li> <li><code>command</code>: Operation type (install or increment)</li> <li><code>feature</code>: Additional features (currently unused)</li> </ul> </li> </ul> <p>You can customize the <code>createCommand</code> function to pack different types of data based on your application's needs. Here are some examples of how you might modify the bit layout:</p> <ol> <li> <p>Game Commands: <pre><code>// 32 bits nonce + 8 bits gameType + 8 bits playerId + 16 bits command\nfunction createGameCommand(nonce: bigint, gameType: bigint, playerId: bigint, command: bigint) {\n    return (nonce &lt;&lt; 32n) + (gameType &lt;&lt; 24n) + (playerId &lt;&lt; 16n) + command;\n}\n</code></pre></p> </li> <li> <p>Transaction Commands: <pre><code>// 32 bits nonce + 16 bits amount + 8 bits tokenId + 8 bits command\nfunction createTxCommand(nonce: bigint, amount: bigint, tokenId: bigint, command: bigint) {\n    return (nonce &lt;&lt; 32n) + (amount &lt;&lt; 16n) + (tokenId &lt;&lt; 8n) + command;\n}\n</code></pre></p> </li> <li> <p>NFT Commands: <pre><code>// 16 bits nonce + 32 bits tokenId + 8 bits collection + 8 bits command\nfunction createNFTCommand(nonce: bigint, tokenId: bigint, collection: bigint, command: bigint) {\n    return (nonce &lt;&lt; 48n) + (tokenId &lt;&lt; 16n) + (collection &lt;&lt; 8n) + command;\n}\n</code></pre></p> </li> </ol> <p>When designing your command structure, consider:</p> <ul> <li>The size needed for each field</li> <li>Priority and access frequency of fields</li> <li>Future extensibility requirements</li> </ul> <p>Remember to provide corresponding extraction functions for unpacking the data when needed.</p>"},{"location":"Quick%20Tutorial.html#player-class","title":"Player Class","text":"<p>The <code>Player</code> class serves as the main interface for interacting with the rollup:</p> <pre><code>export class Player {\n    processingKey: string;\n    rpc: ZKWasmAppRpc;\n\n    constructor(key: string, rpc: string) {\n        this.processingKey = key\n        this.rpc = new ZKWasmAppRpc(rpc);\n    }\n    // ...\n}\n</code></pre> <p>Key methods in the Player class:</p>"},{"location":"Quick%20Tutorial.html#1-state-query","title":"1. State Query","text":"<p><pre><code>async getState(): Promise&lt;any&gt; {\n    let state:any = await this.rpc.queryState(this.processingKey);\n    return JSON.parse(state.data);\n}\n</code></pre> The <code>getState</code> method:</p> <ul> <li>Retrieves the current state for a player</li> <li>Returns parsed JSON data containing player information</li> </ul>"},{"location":"Quick%20Tutorial.html#2-nonce-management","title":"2. Nonce Management","text":"<pre><code>async getNonce(): Promise&lt;bigint&gt; {\n    let state:any = await this.rpc.queryState(this.processingKey);\n    let nonce = 0n;\n    if (state.data) {\n        let data = JSON.parse(state.data);\n        if (data.player) {\n            nonce = BigInt(data.player.nonce);\n        }\n    }\n    return nonce;\n}\n</code></pre> <p>The <code>getNonce</code> method:</p> <ul> <li>Retrieves the current nonce (transaction sequence number) for a player</li> <li>Essential for transaction ordering and replay protection</li> </ul>"},{"location":"Quick%20Tutorial.html#3-player-registration","title":"3. Player Registration","text":"<pre><code>async register() {\n    let nonce = await this.getNonce();\n    try {\n        let result = await this.rpc.sendTransaction(\n            new BigUint64Array([createCommand(nonce, CMD_INSTALL_PLAYER, 0n), 0n, 0n, 0n]),\n            this.processingKey\n        );\n        return result\n    } catch(e) {\n        if (e instanceof Error) {\n            console.log(e.message);\n        }\n    }\n}\n</code></pre> <p>The <code>register</code> method:</p> <ul> <li>Registers a new player in the system</li> <li>Creates and sends an installation transaction</li> <li>Handles potential errors during registration</li> </ul>"},{"location":"Quick%20Tutorial.html#4-counter-increment","title":"4. Counter Increment","text":"<pre><code>async incCounter() {\n    let nonce = await this.getNonce();\n    try {\n        let result = await this.rpc.sendTransaction(\n            new BigUint64Array([createCommand(nonce, CMD_INC_COUNTER, 0n), 0n, 0n, 0n]), \n            this.processingKey\n        );\n        return result;\n    } catch(e) {\n        if (e instanceof Error) {\n            console.log(e.message);\n        }\n    }\n}\n</code></pre> <p>The <code>incCounter</code> method:</p> <ul> <li>Increments the player's counter</li> <li>Creates and sends an increment transaction</li> <li>Handles potential errors during the operation</li> </ul>"},{"location":"Quick%20Tutorial.html#usage-example","title":"Usage Example","text":"<p>Here's how you might use the client-side API to interact or test with the hello world zkWasm rollup backend, this is also the way to integrate the API into your frontend application:</p> <pre><code>// Initialize a player\nconst player = new Player(\"processingKey\", \"http://localhost:3000\");\n\n// Register the player\nawait player.register();\n\n// Get player state\nconst state = await player.getState();\nconsole.log(\"Player state:\", state);\n\n// Increment counter\nawait player.incCounter();\n</code></pre> <p>Note</p> <p>You may notice that the \"processingKey\" is actually the key for accessing the zkWasm rollup application, it is required and used to sign the data in every transaction to the zkWasm rollup application. In real implementation, you need to generate a processingKey from the user's signature, which is derived from a unique message signed by the user's private key. Please remind your user to keep this key secure and never expose it to the public, as well as never signing a same message with the same private key.</p>"},{"location":"Quick%20Tutorial.html#step-5-implementing-your-own-rollup-application","title":"Step 5: Implementing your own Rollup Application","text":"<p>Now that you have a basic understanding of the zkWasm rollup application, you can start to implement your own application by referring to the hello world rollup application.</p> <p>Let's first complete the hello world rollup application by implementing the <code>inc_counter</code> method in <code>src/state.rs</code>. This method increments the <code>counter</code> field in the <code>PlayerData</code> struct by 1. You can use this pattern to implement similar state changes in your own rollup application.</p> <pre><code>pub fn inc_counter(&amp;self, _pkey: &amp;[u64; 4]) -&gt; u32 {\n    // Convert player's public key to player ID\n    let pid = HelloWorldPlayer::pkey_to_pid(_pkey);\n    // Try to get the player instance using the ID\n    let player = HelloWorldPlayer::get_from_pid(&amp;pid);\n\n    // Match on the optional player result\n    match player {\n        // If player exists\n        Some(mut p) =&gt; {\n            // Increment the player's counter\n            p.data.counter += 1;\n            // Store the updated state\n            p.store();\n            // Return 0 to indicate success\n            0\n        },\n        // If player doesn't exist, return error\n        None =&gt; ERROR_PLAYER_NOT_EXIST\n    }\n}\n</code></pre> <p>Let's break down the key components of this implementation:</p>"},{"location":"Quick%20Tutorial.html#1-player-identification","title":"1. Player Identification","text":"<p>When you want to access or modify the state of a player, you need to identify the player first. In the hello world rollup application, the player is identified by the player's ID, which is a unique identifier derived from the player's public key.</p> <ul> <li><code>HelloWorldPlayer::pkey_to_pid(_pkey)</code>: Converts the public key to a player ID</li> <li><code>HelloWorldPlayer::get_from_pid(&amp;pid)</code>: Retrieves the player instance using the ID</li> </ul>"},{"location":"Quick%20Tutorial.html#2-state-management","title":"2. State Management","text":"<p>Remember that player may not exist, so you need to check if the player exists before accessing or modifying its state.</p> <ul> <li>Uses pattern matching (<code>match</code>) to handle both existing and non-existing player cases</li> <li>For existing players:<ul> <li>Increments the counter: <code>p.data.counter += 1</code></li> <li>Persists the change: <code>p.store()</code></li> <li>Returns 0 to indicate success</li> </ul> </li> <li>For non-existing players:<ul> <li>Returns <code>ERROR_PLAYER_NOT_EXIST</code></li> </ul> </li> </ul>"},{"location":"Quick%20Tutorial.html#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Returns appropriate error codes based on the operation result</li> <li>Uses the previously defined <code>ERROR_PLAYER_NOT_EXIST</code> constant</li> </ul> <p>This implementation demonstrates several important patterns for building your own rollup application:</p> <ol> <li>State Access: How to access and modify player-specific state</li> <li>Error Handling: How to handle various edge cases and error conditions</li> <li>State Persistence: How to properly store updated state</li> <li>Player Management: How to handle player existence checks</li> </ol> <p>When implementing your own rollup application, you can follow similar patterns to:</p> <ul> <li>Define your own state structures</li> <li>Implement state modification methods</li> <li>Handle errors appropriately</li> <li>Ensure proper state persistence</li> </ul>"},{"location":"Quick%20Tutorial.html#modifying-the-global-state","title":"Modifying the Global State","text":"<p>The global state of the rollup application is maintained in the <code>STATE</code> variable, which is a global variable. When you want to modify the global state, you need to update the <code>STATE</code> variable. For example, in process method in the <code>Transaction</code> struct, we have the following code:</p> <pre><code>match self.command {\n    AUTOTICK =&gt; {\n        unsafe { STATE.tick() };\n        return 0;\n    },\n    ...\n}\n</code></pre> <p>This is the way to modify the global state of the rollup application, and the tick method is defined in the <code>State</code> struct as:</p> <pre><code>pub fn tick(&amp;mut self) {\n    self.counter += 1;\n}\n</code></pre> <p>Remember that any state modifications for players should be:</p> <ul> <li>Atomic and consistent</li> <li>Properly persisted using the <code>store()</code> method</li> <li>Protected with appropriate existence checks</li> <li>Accompanied by proper error handling</li> </ul> <p>However, for Global State, you don't need to consider the existence of players, and you can directly modify the <code>STATE</code> variable as it is defined as mutable.</p> <p>By following these patterns, you can implement various types of state changes in your own rollup application while maintaining consistency and reliability.</p>"},{"location":"Setup%20Environment.html","title":"Setup Environment","text":""},{"location":"Setup%20Environment.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Rust programming language and Cargo.</li> <li>Basic knowledge of Makefile.</li> <li>Basic knowledge of Docker.</li> <li>Basic knowledge of TypeScript and Node.js.</li> </ul>"},{"location":"Setup%20Environment.html#nodejs-setup","title":"Node.js Setup","text":"<p>Install Node.js and npm</p> <p>To install Node.js and npm, follow these steps:</p> <ol> <li>Visit the Node.js download page and download the LTS version for your operating system.</li> <li>Run the installer and follow the setup instructions.</li> <li>Ensure that you check the option to install npm along with Node.js.</li> </ol> <p>Verify Installation</p> <p>After installation, verify Node.js, npm, and npx are properly installed: <pre><code>node --version\nnpm --version\nnpx --version    # npx comes with npm 5.2.0+\n</code></pre></p> <p>About npx</p> <ul> <li>npx comes bundled with npm version 5.2.0 and higher</li> <li>If npx command is not found, update npm: <pre><code>npm install -g npm@latest\n</code></pre></li> <li>Or install npx explicitly: <pre><code>npm install -g npx\n</code></pre></li> </ul> <p>Note for Windows Users</p> <p>If you encounter issues with permissions or paths, consider using nvm-windows to manage Node.js versions.</p> <p>Using nvm for Node.js</p> <p>If you prefer using a version manager, you can use nvm (Node Version Manager):</p> <ul> <li> <p>For macOS/Linux: <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\nsource ~/.bashrc\nnvm install --lts\n</code></pre></p> </li> <li> <p>For Windows, use nvm-windows and follow the installation instructions on the GitHub page.</p> </li> </ul> <p>Package Manager Installation</p> <p>If you need to install package managers first:</p> <ul> <li>Homebrew (macOS): Installation Guide</li> <li>apt (Ubuntu/Debian): Pre-installed, or use:  <pre><code>sudo apt update &amp;&amp; sudo apt install apt\n</code></pre></li> <li>Chocolatey (Windows): Installation Guide</li> </ul>"},{"location":"Setup%20Environment.html#rust-setup","title":"Rust Setup","text":"<p>Install Rust</p> <p>If you haven't installed Rust, you can install it using rustup: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p> <p>Verify Installation</p> <p>After installation, verify Rust and Cargo are properly installed: <pre><code>rustc --version\ncargo --version\n</code></pre></p> <p>Note for Windows Users</p> <p>If you're using Windows, we recommend:</p> <ol> <li>Using Windows Subsystem for Linux (WSL)</li> <li>Or installing Rust through the official installer from rustup.rs</li> </ol> <p>Optional: IDE Setup</p> <p>We recommend using VS Code with the following extensions:</p> <ul> <li>rust-analyzer</li> <li>Even Better TOML</li> <li>CodeLLDB</li> </ul>"},{"location":"Setup%20Environment.html#install-make","title":"Install Make","text":"<p>Linux/macOS Users</p> <p>For Unix-based systems, Make is usually pre-installed. If not:</p> <p>Ubuntu/Debian: <pre><code>sudo apt update\nsudo apt install build-essential\n</code></pre></p> <p>macOS: <pre><code>xcode-select --install\n</code></pre></p> <p>Windows Setup for Make</p> <p>Windows users have several options:</p> <ol> <li> <p>Using Chocolatey (Recommended): <pre><code>choco install make\n</code></pre></p> </li> <li> <p>Using MSYS2: <pre><code># First install MSYS2 from https://www.msys2.org/\n# Then open MSYS2 terminal and run:\npacman -S make\n</code></pre></p> </li> <li> <p>Using WSL (Best Option): <pre><code># Install WSL first\nwsl --install\n\n# After WSL is installed, open Ubuntu terminal and run:\nsudo apt update\nsudo apt install build-essential\n</code></pre></p> </li> </ol> <p>Verify Installation</p> <p>After installation, verify Make is properly installed: <pre><code>make --version\n</code></pre></p> <p>Package Manager Installation</p> <p>If you need to install package managers first:</p> <ul> <li>Chocolatey: Installation Guide</li> <li>MSYS2: Download Page</li> <li>WSL: Microsoft Guide</li> </ul> <p>After installing the package manager, make sure you correctly setup the environment variables for the package manager.</p>"},{"location":"Setup%20Environment.html#docker-setup","title":"Docker Setup","text":"<p>Install Docker</p> <p>Choose your operating system and follow the installation steps:</p> <ol> <li> <p>For Ubuntu/Debian: <pre><code># Remove old versions\nsudo apt-get remove docker docker-engine docker.io containerd runc\n\n# Install dependencies\nsudo apt-get update\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n\n# Add Docker's official GPG key\nsudo mkdir -m 0755 -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# Set up the repository\necho \\\n    \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n    $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n# Install Docker Engine\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre></p> </li> <li> <p>For macOS:</p> <ul> <li>Download Docker Desktop for Mac</li> <li>Double-click the downloaded <code>.dmg</code> file and drag Docker to Applications</li> <li>Start Docker from Applications</li> </ul> </li> <li> <p>For Windows:</p> <ul> <li>Enable WSL 2 feature</li> <li>Download Docker Desktop for Windows</li> <li>Run the installer and follow the prompts</li> </ul> </li> </ol> <p>Verify Installation</p> <p>After installation, verify Docker is properly installed: <pre><code>docker --version\ndocker compose version\n</code></pre></p> <p>Post-installation Steps</p> <p>To use Docker without sudo (Linux): <pre><code># Create docker group\nsudo groupadd docker\n\n# Add your user to docker group\nsudo usermod -aG docker $USER\n\n# Apply new group membership (or log out and back in)\nnewgrp docker\n</code></pre></p> <p>Test Docker Installation</p> <p>Run a test container: <pre><code>docker run hello-world\n</code></pre></p>"},{"location":"zkWasm%20Overview.html","title":"zkWasm Overview","text":""},{"location":"zkWasm%20Overview.html#1-introduction-to-zkwasm","title":"1. Introduction to zkWasm","text":"<p>Note</p> <p>This section provides a high-level overview of zkWasm. For more detailed information about zkWasm, please refer to the:</p> <ul> <li>zkWasm Whitepaper</li> <li>zkWasm Book</li> </ul> <p>zkWasm represents a fundamental advancement in the field of trustless computation by combining WebAssembly with zero-knowledge proofs. The system implements a complete WebAssembly virtual machine within zkSNARK circuits, creating a bridge between traditional application development and blockchain technology. This approach allows developers to write programs in familiar languages while gaining the benefits of zero-knowledge proofs without requiring specialized cryptographic knowledge.</p> <p>The core innovation of zkWasm lies in its approach to implementing zero-knowledge proofs. Rather than requiring developers to write programs in specialized circuit-friendly languages, zkWasm applies zero-knowledge proofs at the bytecode level of the virtual machine. This means that any program that can be compiled to WebAssembly can automatically benefit from zero-knowledge capabilities, making the technology accessible to a much broader range of developers and applications. </p> <p>Traditional approaches to implementing zero-knowledge proofs often require developers to work with specialized languages and tools like Pinocchio, TinyRAM, or ZoKrates. This requirement creates a significant barrier to adoption, as developers must learn new programming paradigms and rewrite existing applications. zkWasm eliminates this barrier by operating at the WebAssembly level, allowing developers to work in languages they already know, such as C++, Rust, or AssemblyScript.</p> <p></p> <p>This accessibility extends beyond just the programming language choice. While traditional blockchain development requires extensive knowledge of specific blockchain protocols and smart contract languages, zkWasm further simplifies the blockchain integration process. By operating at the WebAssembly bytecode level, zkWasm automatically handles the generation of zero-knowledge proofs for any application logic like user operations and user interactions. These standardized proofs can be verified on any blockchain platform without requiring developers to write custom smart contracts or complex blockchain-specific protocols for application logic. This approach not only lowers the technical barriers for Web2 developers (as well as their users) entering the Web3 space, but also enables seamless cross-chain compatibility for their applications. </p> <p>Info</p> <p>Compared to the traditional Web3 applications which heavily rely on smart contracts and a specific blockchain system, zkWasm applications are more like Web2 applications, but with the trustless verification capabilities brought by zero-knowledge proofs, it can:</p> <ul> <li>Seamlessly integrate with existing Web2 or Web3 applications</li> <li>Allow developers to focus on business logic and frontend design, without the need to learn much about blockchain or zero-knowledge proofs</li> <li>Allow developers to easily switch between different blockchain platforms if needed</li> <li>Allow developers to easily scale or upgrade their applications</li> <li>Allow gasless interactions and operations (except for the proof verification, deposit and withdrawal which is required when manipulating the onchain assets) for application users</li> </ul>"},{"location":"zkWasm%20Overview.html#2-the-state-machine-foundation","title":"2. The State Machine Foundation","text":"<p>At its core, zkWasm operates as a state machine that processes WebAssembly bytecode while generating proofs of correct execution. The state machine takes as input a tuple consisting of several key components that together define the program and its execution environment. This tuple, represented as (I(C,H), E, IO), contains the WebAssembly executable image I (which includes both code C and initial memory state H), the entry point E, and the input/output firmware IO.</p> <p>The state machine maintains an internal state that captures every aspect of program execution. This state, represented as a tuple (iaddr, F, M, G, Sp, I, IO), includes the current instruction address (iaddr), the call frame (F), memory state (M), global variables (G), and the execution stack (Sp). Each of these components plays a crucial role in program execution and proof generation.</p> <p>Note</p> <p>Understanding the state machine model is crucial for application development because:</p> <ul> <li>Design the state machine model before starting to write code will help a lot on development efficiency</li> <li>Your application's performance depends on minimizing state transitions</li> <li>Proper state handling is essential for correctness and security of your application</li> <li>Consider using tools to analyze your application's state transitions during development</li> </ul>"},{"location":"zkWasm%20Overview.html#state-representation-and-execution-flow","title":"State Representation and Execution Flow","text":"<p>The instruction address (iaddr) keeps track of the current position in the program, determining which instruction will be executed next. The call frame (F) manages function calls and their context, including a depth field that tracks the nesting level of function calls. This depth tracking is crucial for ensuring that all function calls properly return and maintaining the correct execution context. </p> <p>Memory management in zkWasm is handled through the memory state (M), which represents the linear memory space available to the WebAssembly program. This memory can be read from and written to during program execution, with all operations being tracked and verified through the proof system. Global variables (G) provide a way to maintain state across function calls, while the stack (Sp) handles temporary values and computation results.</p> <p>Program execution proceeds through a series of state transitions, with each transition function taking the current state and producing a new state based on the instruction being executed. These transitions form an execution trace that represents the complete history of program execution. The system ensures that each transition follows the WebAssembly specification and maintains the integrity of the program state.</p> <p>Here's a core state structure in Rust:</p> <pre><code>struct State {\n    iaddr: InstructionAddress,  // Current instruction address\n    F: CallFrame,               // Call frame with depth\n    M: MemoryState,            // Memory state\n    G: GlobalVariables,        // Global variables\n    Sp: Stack,                 // Execution stack\n    I: WasmImage,              // WASM executable image\n    IO: IOFirmware            // Input/Output handling\n}\n</code></pre> <p>State transitions and execution can be defined as:</p> <pre><code>type StateTransition = fn(State) -&gt; State;\n\nstruct ExecutionTrace {\n    transitions: Vec&lt;StateTransition&gt;,\n    initial_state: State,\n}\n</code></pre> <p>Let's examine a concrete example of how state transitions work in practice:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n</code></pre> <p>This simple addition function generates several state transitions under the hood. Here's what happens:</p> <pre><code>let transitions = vec![\n    // Load first parameter\n    |s| State { \n        stack: s.stack.push(s.memory[s.iaddr + 1]),\n        iaddr: s.iaddr + 1,\n        ..s\n    },\n    // Load second parameter\n    |s| State {\n        stack: s.stack.push(s.memory[s.iaddr + 1]),\n        iaddr: s.iaddr + 1,\n        ..s\n    },\n    // Perform addition\n    |s| {\n        let (stack, y) = s.stack.pop();\n        let (stack, x) = stack.pop();\n        State {\n            stack: stack.push(x + y),\n            iaddr: s.iaddr + 1,\n            ..s\n        }\n    }\n];\n</code></pre> <p>Each transition represents a specific operation in the WebAssembly execution:</p> <ol> <li>The first transition loads parameter x from memory onto the stack</li> <li>The second transition loads parameter y</li> <li>The final transition pops both values, adds them, and pushes the result</li> </ol> <p>The validity of an execution trace is verified as follows:</p> <pre><code>impl ExecutionTrace {\n    fn is_valid(&amp;self) -&gt; bool {\n        let mut current_state = self.initial_state;\n\n        // Verify each transition\n        for transition in &amp;self.transitions {\n            current_state = transition(current_state);\n\n            // Verify transition follows WASM semantics\n            if !verify_semantics(current_state) {\n                return false;\n            }\n        }\n\n        // Verify final state\n        current_state.call_frame.depth == 0\n    }\n}\n</code></pre>"},{"location":"zkWasm%20Overview.html#3-host-builtin-functions","title":"3. Host (Builtin) Functions","text":"<p>Besides the WebAssembly instructions, zkWasm also provides a set of host functions that are not defined in the WebAssembly module itself but are provided by the environment in which the WebAssembly code is executed. These functions are crucial for WebAssembly modules to interact with the outside world, as WASM on its own is quite sandboxed and limited in what it can do directly.</p> <p>Here are some key points about WASM host functions:</p> <ul> <li>Interaction with the Environment: WASM is designed to be a low-level, portable bytecode, which runs in a sandboxed environment. By itself, it doesn't have direct access to the system's resources like file systems, network, or the DOM in web browsers. Host functions serve as the bridge between the WASM code and these external resources.</li> <li>Provided by the Host Environment: The host environment (which could be a web browser, a server-side platform like Node.js, or any other system that supports running WebAssembly) defines and provides these host functions. For instance, in a web browser, the host functions might allow interactions with web APIs.</li> <li>Imported into WASM Modules: WASM modules import these host functions and use them as if they were part of the module. This import/export mechanism is part of the WASM design, allowing for modular code and separation of concerns.</li> <li>Custom Functionality: Host functions can be used to provide custom functionality to WASM modules that is not available in the standard WASM instruction set. This can include anything from accessing the file system to performing complex computations that are more efficiently done in the host language (like JavaScript in the case of web browsers).</li> </ul> <p>In the zkWasm system, a wide range of pre-defined host functions are provided to make it easier to build complex applications. These host functions are divided into three main categories:</p> <ul> <li>I/O related host functions: These functions handle the input and output operations in zkWasm. They provide ways for reading both public and private inputs, keeping track of the current position in the input stream, and outputting results. The difference between public and private inputs is very important for zero-knowledge applications.</li> <li>Merkle tree related host functions: zkWasm includes a Merkle tree implementation for efficiently verifying large data structures. The Merkle tree host functions include setting the root, specifying leaf addresses, updating and retrieving values, and getting the root hash. These functions follow a specific set of rules to ensure consistency and verifiability.</li> <li>Cryptographic operation related host functions: zkWasm implements advanced cryptographic operations, particularly the Poseidon signature scheme, which works well with zero-knowledge proofs. The signature host functions use elliptic curve cryptography (through the BabyJubjub curve) and involve multi-scalar multiplication for verification. These functions provide a secure and efficient way to perform cryptographic operations within the zkWasm environment.</li> </ul> <p>Note</p> <p>When developing zkWasm applications:</p> <ul> <li>Use host functions for external interactions and cryptographic operations (like user operations and signature)</li> <li>Carefully manage the distinction between public and private inputs</li> <li>Leverage the Merkle tree functions for efficient data structure storage, retrieval, and verification, because in zkWasm, we implement Merkle tree as Database Service.</li> <li>Design your application architecture around these built-in capabilities rather than implementing custom solutions.    </li> </ul>"},{"location":"zkWasm%20Overview.html#inputoutput-system-implementation","title":"Input/Output System Implementation","text":"<p>The input/output system in zkWasm provides a mechanism for handling both public and private data. The system centers around the zkmain function, which serves as the entry point for all zkWasm applications. This function has the signature zkmain(void): (void), but can interact with the outside world through specialized host functions.</p> <p>zkWasm distinguishes between public and private inputs through its input functions:</p> <ul> <li><code>zkwasm_input(1)</code> reads public inputs (instances) that will be visible in the proof. </li> <li><code>zkwasm_input(0)</code> handles private inputs (witnesses) that should remain confidential. </li> </ul> <p>This distinction is crucial for zero-knowledge applications, where some data must remain private while still proving computations were performed correctly.</p> <p>The system maintains an internal cursor that tracks the current position in the input stream. When reading inputs, the system takes the value at the current cursor position, places it on top of the execution stack, and advances the cursor. This mechanism ensures orderly processing of inputs while maintaining the distinction between public and private data.</p>"},{"location":"zkWasm%20Overview.html#merkle-tree-integration","title":"Merkle Tree Integration","text":"<p>An integral part of the I/O system is the Merkle tree implementation, which provides efficient verification of large data structures. zkWasm includes a built-in Merkle tree with a depth of 32 levels, supporting indices from 0 to 2^32-1. </p> <p>The Merkle tree API provides the following functions:</p> <pre><code>extern \"C\" {\n    pub fn merkle_setroot(x: u64);\n    pub fn merkle_address(x: u64);\n    pub fn merkle_set(x: u64);\n    pub fn merkle_get() -&gt; u64;\n    pub fn merkle_getroot() -&gt; u64;\n}\n</code></pre> <ul> <li><code>merkle_setroot</code>: Sets the Merkle root to establish the context.</li> <li><code>merkle_address</code>: Specifies the leaf address for the operation.</li> <li><code>merkle_set</code>: Updates the value at the currently selected address.</li> <li><code>merkle_get</code>: Retrieves the value at the currently selected address, along with a proof of inclusion.</li> <li><code>merkle_getroot</code>: Returns the current root hash, which represents the entire state of the tree.</li> </ul> <p>The Merkle tree operations follow a specific protocol to ensure consistency and verifiability. Here's an example:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn merkle_tree_example() {\n    unsafe {\n        // Set up Merkle tree state\n        let root = [1u64, 2u64, 3u64, 4u64];  // Example root\n\n        // Set root for operations\n        for (i, &amp;value) in root.iter().enumerate() {\n            merkle_setroot(value);\n        }\n\n        // Query leaf at index 0\n        merkle_address(0);\n        let value = merkle_get();\n\n        // Update leaf value\n        merkle_set(value + 1);\n\n        // Get new root after modification\n        let new_root = merkle_getroot();\n        zkwasm_output(new_root);\n    }\n}\n</code></pre> <p>This example demonstrates a complete Merkle tree operation cycle:</p> <ol> <li>First, it initializes the tree with a known root</li> <li>Then it queries a specific leaf value</li> <li>Updates that value</li> <li>Finally retrieves the new root hash that reflects the change</li> </ol> <p>The Merkle tree implementation supports efficient verification of data integrity. Here's an example of how verification works:</p> <pre><code>pub struct MerkleProof {\n    leaf_value: u64,\n    path: Vec&lt;(u64, bool)&gt;,  // (hash, is_left)\n    root: u64,\n}\n\nimpl MerkleProof {\n    pub fn verify(&amp;self) -&gt; bool {\n        let mut current_hash = self.leaf_value;\n\n        // Traverse the path from leaf to root\n        for &amp;(sibling_hash, is_left) in &amp;self.path {\n            current_hash = if is_left {\n                hash_pair(sibling_hash, current_hash)\n            } else {\n                hash_pair(current_hash, sibling_hash)\n            };\n        }\n\n        current_hash == self.root\n    }\n}\n</code></pre> <p>This verification process ensures that a particular leaf value is indeed part of the Merkle tree with the given root. The path provides the necessary sibling hashes to reconstruct the root hash.</p>"},{"location":"zkWasm%20Overview.html#signature-scheme","title":"Signature Scheme","text":"<p>zkWasm implements the Poseidon signature scheme, which leverages elliptic curve cryptography through the BabyJubjub curve, providing efficient verification while maintaining security.</p> <p>The signature consists of two components: - sig_r: A point on the BabyJubjub elliptic curve - sig_s: A scalar value used in the signature verification equation</p> <pre><code>struct JubjubSignature {\n    sig_r: BabyJubjubPoint,\n    sig_s: Scalar,\n}\n</code></pre> <p>This verification process involves several steps:</p> <ol> <li>It performs a multi-scalar multiplication (msm) combining:</li> <li>The public key with the message hash</li> <li>The signature's R point with the constant ONE</li> <li>The negative of the base point with the s value</li> <li>The result should be the point (0, 1) if the signature is valid</li> </ol> <pre><code>impl JubjubSignature {\n    pub fn verify(&amp;self, pk: &amp;BabyJubjubPoint, msghash: &amp;[u64; 4]) {\n        unsafe {\n            let r = BabyJubjubPoint::msm(&amp;[\n                (pk, msghash),\n                (&amp;self.sig_r, &amp;ONE.0),\n                (&amp;NEG_BASE, &amp;self.sig_s),\n            ]);\n\n            require(r.x.is_zero() &amp;&amp; r.y == ONE);\n        }\n    }\n}\n</code></pre> <p>Let's look at how this is used in practice:</p> <pre><code>#[no_mangle]\npub extern \"C\" fn verify_signature_example() {\n    unsafe {\n        // Read signature components from input\n        let sig_r_x = zkwasm_input(0);\n        let sig_r_y = zkwasm_input(0);\n        let sig_s = zkwasm_input(0);\n\n        // Read public key\n        let pk_x = zkwasm_input(1);\n        let pk_y = zkwasm_input(1);\n\n        // Read message hash\n        let msg_hash = [\n            zkwasm_input(1),\n            zkwasm_input(1),\n            zkwasm_input(1),\n            zkwasm_input(1),\n        ];\n\n        // Construct signature object\n        let signature = JubjubSignature {\n            sig_r: BabyJubjubPoint::new(sig_r_x, sig_r_y),\n            sig_s: Scalar::new(sig_s),\n        };\n\n        // Verify signature\n        let pk = BabyJubjubPoint::new(pk_x, pk_y);\n        signature.verify(&amp;pk, &amp;msg_hash);\n\n        // Output verification result\n        zkwasm_output(1);  // Success if we reach here\n    }\n}\n</code></pre>"},{"location":"zkWasm%20Overview.html#4-proof-generation-and-verification","title":"4. Proof Generation and Verification","text":"<p>The proof generation system in zkWasm handles the complexity of real-world applications through a segmentation approach. This is necessary because execution traces can contain millions of instructions, far exceeding what can be proved in a single circuit. The system breaks down long execution traces into manageable segments, each with its own proof, which are then combined into a complete verification of the entire execution.</p> <p>Note</p> <p>To optimize proof generation in your applications:</p> <ul> <li>Design with proof segmentation in mind</li> <li>Batch related operations to minimize segment boundaries</li> <li>Implement proper error handling that doesn't leak private information</li> <li>Consider the trade-offs between segment size and proof generation time</li> </ul> <p>Each execution segment maintains its own starting state, sequence of instructions, ending state, and proof of correct execution:</p> <pre><code>struct ExecutionSegment {\n    start_state: State,\n    instructions: Vec&lt;Instruction&gt;,\n    end_state: State,\n    proof: SegmentProof,\n}\n</code></pre> <p>This structure represents a single segment of execution. Let's understand each component:</p> <ul> <li>start_state: Contains the complete state at the beginning of the segment</li> <li>instructions: The list of WebAssembly instructions executed in this segment</li> <li>end_state: The resulting state after executing all instructions</li> <li>proof: The zero-knowledge proof for this segment's execution</li> </ul> <p>The proof generation system uses these segments as building blocks. Here's how a segment is processed:</p> <pre><code>impl ExecutionSegment {\n    fn process_segment(&amp;mut self) -&gt; Result&lt;(), Error&gt; {\n        let mut current_state = self.start_state.clone();\n\n        // Execute each instruction and track state changes\n        for instruction in &amp;self.instructions {\n            // Execute instruction\n            current_state = execute_instruction(current_state, instruction)?;\n\n            // Verify state transition\n            verify_state_transition(&amp;current_state)?;\n\n            // Generate constraints for the proof\n            self.proof.add_constraints(current_state.clone())?;\n        }\n\n        // Verify final state matches expected end state\n        if current_state != self.end_state {\n            return Err(Error::StateMismatch);\n        }\n\n        Ok(())\n    }\n}\n</code></pre> <p>This implementation shows how each segment maintains execution integrity:</p> <ol> <li>It starts from the initial state</li> <li>Processes each instruction sequentially</li> <li>Verifies state transitions</li> <li>Generates proof constraints</li> <li>Ensures the final state matches expectations</li> </ol> <p>Additionally, segments are grouped into bundles for efficient management:</p> <pre><code>struct BundleExecution {\n    segments: Vec&lt;ExecutionSegment&gt;,\n    continuation_proof: ContinuationProof,\n}\n</code></pre> <p>Segments are grouped into bundles for efficient management:</p> <pre><code>struct BundleExecution {\n    segments: Vec&lt;ExecutionSegment&gt;,\n    continuation_proof: ContinuationProof,\n}\n\nimpl BundleExecution {\n    fn new() -&gt; Self {\n        BundleExecution {\n            segments: Vec::new(),\n            continuation_proof: ContinuationProof::default(),\n        }\n    }\n\n    fn add_segment(&amp;mut self, segment: ExecutionSegment) -&gt; Result&lt;(), Error&gt; {\n        // Verify segment connects with previous one\n        if let Some(last_segment) = self.segments.last() {\n            if last_segment.end_state != segment.start_state {\n                return Err(Error::SegmentMismatch);\n            }\n        }\n\n        // Process and add segment\n        segment.process_segment()?;\n        self.segments.push(segment);\n\n        Ok(())\n    }\n\n    fn finalize(&amp;mut self) -&gt; Result&lt;(), Error&gt; {\n        // Generate continuation proof\n        self.continuation_proof = ContinuationProof::connect_segments(&amp;self.segments)?;\n\n        // Verify bundle consistency\n        self.verify_bundle_integrity()?;\n\n        Ok(())\n    }\n}\n</code></pre> <p>The system ensures that segments connect properly, with the ending state of one segment matching the starting state of the next. This segmentation allows for efficient proof generation while maintaining the security and correctness of the overall system.</p> <p>zkWasm generates three types of proofs that work together to verify program execution:</p> <ol> <li>Guest Circuit Proofs: Verify the correct execution of WebAssembly instructions within a segment. These proofs ensure that each instruction follows the WebAssembly specification.</li> <li>Host Circuit Proofs: Validate external function calls and their results. These proofs verify that interactions with the environment (through host functions) are correct.</li> <li>Aggregation Circuit Proofs: Combine multiple proofs into a single, verifiable proof. This includes connecting segment proofs and ensuring the overall execution is valid.</li> </ol> <p>The proof generation process begins with individual segment proofs, creates continuation proofs to connect the segments, and finally combines everything into a single, verifiable proof. This hierarchical approach allows zkWasm to handle complex applications while maintaining efficient proof generation and verification.</p>"},{"location":"zkWasm%20Overview.html#5-development-process-and-best-practices","title":"5. Development Process and Best Practices","text":"<p>Developing applications for zkWasm requires careful attention to state management and performance optimization. State changes should be minimized when possible, as each state transition must be proved in the zero-knowledge system. Related operations should be batched together when possible to reduce the number of state transitions and improve proof generation efficiency.</p> <p>Besides, memory management plays a crucial role in zkWasm application performance. The linear memory model of WebAssembly must be used efficiently, with careful attention paid to memory layout and access patterns. Global variables should be used judiciously, as they affect the state that must be tracked and proved.</p> <p>Error handling in zkWasm applications requires special consideration due to the zero-knowledge context. Errors must be handled in a way that doesn't leak information about private data while still providing useful feedback about what went wrong. This often involves careful design of error conditions and appropriate use of public and private inputs. We will cover more about error handling in practice in the later chapters.</p>"},{"location":"zkWasm%20Overview.html#6-architecture-of-a-zkwasm-rollup-application","title":"6. Architecture of a zkWasm Rollup Application","text":""},{"location":"zkWasm%20Rust%20SDK.html","title":"zkWasm Rust SDK","text":""},{"location":"zkWasm%20Rust%20SDK.html#core-components-overview-of-zkwasm-rust-sdk","title":"Core Components Overview of zkWasm Rust SDK","text":"<p>The zkWasm Rust SDK provides essential building blocks for developing zero-knowledge WebAssembly applications. Let's explore the key components.</p>"},{"location":"zkWasm%20Rust%20SDK.html#1-storage-and-state-management","title":"1. Storage and State Management","text":""},{"location":"zkWasm%20Rust%20SDK.html#merkle-tree-state","title":"Merkle Tree State","text":"<pre><code>pub static mut MERKLE_MAP: KeyValueMap&lt;Merkle&gt; = KeyValueMap {\n    merkle: Merkle { root: [...] }\n};\n</code></pre> <ul> <li>Manages application state using a Merkle tree structure</li> <li>Provides cryptographic verification of state changes</li> <li>Uses a key-value store for efficient data access</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#storagedata-trait","title":"StorageData Trait","text":"<pre><code>pub trait StorageData {\n    fn from_data(u64data: &amp;mut IterMut&lt;u64&gt;) -&gt; Self;\n    fn to_data(&amp;self, u64data: &amp;mut Vec&lt;u64&gt;);\n}\n</code></pre> <ul> <li>Defines interface for serializing/deserializing state data</li> <li>Enables custom data structures to be stored in Merkle tree</li> <li>Provides consistent data handling across the application</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#2-player-management-system","title":"2. Player Management System","text":"<p>When developing a zkWasm application, you need to manage players (or users) and their associated data. The player management system is essential for tracking user accounts and their state.</p>"},{"location":"zkWasm%20Rust%20SDK.html#player-structure","title":"Player Structure","text":"<p><pre><code>#[derive(Debug, Serialize)]\npub struct Player&lt;T: StorageData + Default&gt; {\n    pub player_id: [u64; 2],\n    pub nonce: u64,\n    pub data: T,\n}\n</code></pre> Key features:</p> <ul> <li>Generic implementation allowing custom player data</li> <li>Built-in nonce management for transaction ordering</li> <li>Serializable for state persistence</li> <li><code>StorageData</code> trait bounds ensuring proper state handling</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#player-operations","title":"Player Operations","text":"<pre><code>impl&lt;T: StorageData + Default&gt; Player&lt;T&gt; {\n    pub fn store(&amp;self) { ... }\n    pub fn new_from_pid(pid: [u64; 2]) -&gt; Self { ... }\n    pub fn get_from_pid(pid: &amp;[u64; 2]) -&gt; Option&lt;Self&gt; { ... }\n    pub fn get_and_check_nonce(pid: &amp;[u64; 2], nonce: u64) -&gt; Self { ... }\n}\n</code></pre> <ul> <li>State persistence with Merkle tree integration</li> <li>Player creation and retrieval functionality</li> <li>Nonce validation and management</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#3-zkwasm-rest-api","title":"3. ZkWasm REST API","text":"<p>In the Application side, this macro generates essential WebAssembly bindings for zkWasm applications: <pre><code>zkwasm_rest_abi::create_zkwasm_apis!(Transaction, State, Config);\n</code></pre></p>"},{"location":"zkWasm%20Rust%20SDK.html#system-architecture-and-flow","title":"System Architecture and Flow","text":"<p>Now we delve into the REST service API to see how it supports the zkWasm rollup Application. Above figure shows the system execution flow of zkWasm rollup application, and below we will explain each phase in detail.</p>"},{"location":"zkWasm%20Rust%20SDK.html#1-initialization-phase","title":"1. Initialization Phase","text":"<p>The initialization phase in zkWasm rollup serves two critical purposes:</p> <ul> <li>Loading previous chunk's finalized state</li> <li>Setting up new execution environment for transactions</li> </ul> <p><pre><code>pub fn initialize(root: Vec&lt;u64&gt;) {\n    // Load initial Merkle root state\n    let merkle = zkwasm_rust_sdk::Merkle::load([root[0], root[1], root[2], root[3]]);\n    MERKLE_MAP.merkle = merkle;\n    $S::initialize();\n}\n</code></pre> The code above:</p> <ul> <li>Loads initial state from provided Merkle root</li> <li>Sets up state for new transaction input bundle</li> <li>Called at the start of each transaction chunk processing</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#2-transaction-processing-phase","title":"2. Transaction Processing Phase","text":"<p>The transaction processing phase in zkWasm rollup fulfills three essential roles:</p> <ul> <li>Sequential execution of user transactions</li> <li>Maintaining state consistency during updates</li> <li>Accumulating settlement information for later batching</li> </ul> <p><pre><code>// In zkmain()\nfor _ in 0..tx_length {\n    let mut params = Vec::with_capacity(24);\n    for _ in 0..24 {\n        params.push(unsafe {wasm_input(0)});\n    }\n    verify_tx_signature(params.clone());\n    handle_tx(params);\n}\n</code></pre> The code above:</p> <ul> <li>Processes transactions until preemption point</li> <li>Each transaction verified and executed sequentially</li> <li>State updates tracked in Merkle tree</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#3-preemption-check","title":"3. Preemption Check","text":"<p>The preemption mechanism in zkWasm rollup serves two vital functions:</p> <ul> <li>Controlling chunk size for computational efficiency</li> <li>Ensuring deterministic chunk boundaries</li> </ul> <p><pre><code>pub fn preempt() -&gt; bool {\n    $S::preempt()  // Check if state reached preemption point\n}\n</code></pre> The code above:</p> <ul> <li>Determines when to stop processing transactions</li> <li>Usually based on state conditions or limits, such as a counter threshold</li> <li>Critical for chunk management</li> </ul> <p><pre><code>pub fn preempt() -&gt; bool {\n    let state = unsafe {&amp;STATE};\n    return state.counter &gt;= 20;\n}\n</code></pre> For example, in code above, if the counter is greater than 20, the preemption point is reached and the transaction processing will stop.</p>"},{"location":"zkWasm%20Rust%20SDK.html#4-state-finalization","title":"4. State Finalization","text":"<p>The finalization phase in zkWasm rollup serves two critical purposes:</p> <ul> <li>Processing all pending settlements</li> <li>Generating verifiable outputs for the chain</li> </ul> <p>The finalize() function in zkWasm API triggers the settlement process: <pre><code>pub fn finalize() -&gt; Vec&lt;u8&gt; {\n    unsafe {\n        $S::flush_settlement()\n    }\n}\n</code></pre></p> <p>Here's an Example, in the circuit's main function (zkmain()), the finalization produces two key outputs:</p> <ul> <li>New State Root (root)<ul> <li>4 u64 values representing the Merkle root</li> <li>Captures final state after all transactions</li> <li>Used to initialize next chunk's state</li> </ul> </li> <li>Settlement Hash (txdata)<ul> <li>4 u64 values containing SHA256 hash</li> <li>Computed from all withdrawals/settlements</li> <li>Used for on-chain verification of batched operations    </li> </ul> </li> </ul> <p><pre><code>// Step 1: Get settlement data the same way as in the finalize() function\nlet bytes = $S::flush_settlement();\n\n// Step 2: Generate transaction info hash\nlet txdata = conclude_tx_info(bytes.as_slice());\n// txdata is [u64; 4] - contains SHA256 hash of settlement data\n\n// Step 3: Get final Merkle root\nlet root = merkle_ref.merkle.root;  // [u64; 4]\n\n// Step 4: Output all data\nunsafe {\n    // Output Merkle root (4 u64 values)\n    wasm_output(root[0]);\n    wasm_output(root[1]);\n    wasm_output(root[2]);\n    wasm_output(root[3]);\n\n    // Output transaction data hash (4 u64 values)\n    wasm_output(txdata[0]);\n    wasm_output(txdata[1]);\n    wasm_output(txdata[2]);\n    wasm_output(txdata[3]);\n}\n</code></pre> The code above:</p> <ul> <li>Generates new Merkle root for next chunk</li> <li>Outputs settlement information</li> <li>Ensures state consistency across chunks</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#rollup-development-requirements","title":"Rollup Development Requirements","text":"<p>In application side, the following requirements shall be met:</p>"},{"location":"zkWasm%20Rust%20SDK.html#1-state-implementation","title":"1. State Implementation","text":"<pre><code>impl State {\n    fn preempt() -&gt; bool { ... }  // Define chunk boundary conditions\n    fn initialize() { ... }        // Setup initial state\n    fn flush_settlement() -&gt; Vec&lt;u8&gt; { ... } // Prepare state updates\n}\n</code></pre> <p>And some other functions can be implemented in the <code>State</code> trait. <pre><code>pub trait State {\n    fn preempt() -&gt; bool;\n    fn initialize();\n    fn flush_settlement() -&gt; Vec&lt;u8&gt;;\n    // Some other functions\n    fn get_state(pid: Vec&lt;u64&gt;) -&gt; String { ... } // Get state for specific player ID\n    fn snapshot() -&gt; String { ... } // Get current global state\n    fn tick(&amp;mut self) { ... } // Update state if auto-tick is enabled\n    fn store(&amp;self) { ... } // Store state to Merkle tree\n    fn new() -&gt; Self { ... } // Create new state instance\n    fn rand_seed() -&gt; u64 { ... } // Generate random seed\n}\n</code></pre></p>"},{"location":"zkWasm%20Rust%20SDK.html#2-transaction-processing","title":"2. Transaction Processing","text":"<pre><code>impl Transaction {\n    fn decode(command: [u64; 4]) -&gt; Self { ... } // Decode Command      \n    fn process(&amp;self, user_address: &amp;[u64; 4], sig_r: &amp;[u64; 4]) -&gt; u32 { ... } // Process Transaction\n    fn install_player(&amp;self, pkey: &amp;[u64; 4]) -&gt; u32 { ... } // Create player / user Account\n}\n</code></pre>"},{"location":"zkWasm%20Rust%20SDK.html#3-configuration-management","title":"3. Configuration Management","text":"<pre><code>impl Config {\n    fn autotick() -&gt; bool { ... } // Auto-tick configuration\n    fn to_json_string() -&gt; String { ... } // Convert to JSON string\n}\n</code></pre>"},{"location":"zkWasm%20Rust%20SDK.html#example-rollup-flow","title":"Example Rollup Flow","text":"<pre><code>// 1. Initialize state with previous Merkle root\ninitialize(previous_root);\n\n// 2. Process transaction batch\nwhile !preempt() {\n    verify_tx_signature(params);\n    handle_tx(params);\n}\n\n// 3. Generate new Merkle root and settlement data\nfinalize();\n// ...\n</code></pre>"},{"location":"zkWasm%20Rust%20SDK.html#function-overview","title":"Function Overview","text":""},{"location":"zkWasm%20Rust%20SDK.html#1-transaction-handling","title":"1. Transaction Handling","text":"<pre><code>pub fn handle_tx(params: Vec&lt;u64&gt;) -&gt; u32 // Process transaction\n</code></pre> <ul> <li>Params format (24 u64 values)<ul> <li>[0-3]: Command data</li> <li>[4-7]: User address</li> <li>[20-23]: Signature data</li> </ul> </li> <li>Returns error code (0 for success)</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#2-state-management","title":"2. State Management","text":"<pre><code>pub fn get_state(pid: Vec&lt;u64&gt;) -&gt; String // Get state for specific player ID\npub fn snapshot() -&gt; String // Get current global state\n</code></pre> <ul> <li><code>get_state</code>: Retrieves state for specific player ID</li> <li><code>snapshot</code>: Gets current global state</li> <li>Both return JSON-formatted strings</li> </ul>"},{"location":"zkWasm%20Rust%20SDK.html#3-configuration-and-control","title":"3. Configuration and Control","text":"<pre><code>pub fn get_config() -&gt; String // Get configuration\npub fn preempt() -&gt; bool  // Preemption check\npub fn autotick() -&gt; bool // Auto-tick configuration\npub fn randSeed() -&gt; u64  // Random seed\n</code></pre> <ul> <li>Configuration retrieval and system controls</li> <li>All WebAssembly-exposed functions</li> </ul>"}]}